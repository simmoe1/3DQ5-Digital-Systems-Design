### Experiment 4

The main objective of this experiment is to show how to interface a ROM to the VGA controller in order to display characters on the display.

A character ROM can be added to the design, with the font map of each character captured in the “MIF” file. In the reference design from this experiment, each displayed character is of size 8 x 8. The entire image can be viewed as a two-dimensional grid of 8 x 8 boxes, where the shape of the character in each box is defined by its corresponding font map from the character ROM. The three least significant bits of the line counter (driven by the VGA controller) identify the font row and the three least significant bits of the column counter identify the font column. The address for the character ROM is provided by the user logic, depending on the character to be displayed in the corresponding box (this is dependent on the specific application requirements).

The design from this experiment is set-up to operate in the 800 x 600 @ 72 fps mode. Hence, the total number of characters that can be displayed is (800/8) x (600/8) = 7,500 (a total of 75 character rows with 100 characters per row). There are two messages that are displayed (approximately) in the middle of the screen: one is a welcome message that is independent of the user input, and the other is a single character message that shows the numerical character that was pressed on the PS/2 keyboard most recently. If the most recently pressed key is not a numerical key, then space is displayed (i.e., no shape).

Although the design seems to work, there is a subtle issue worth discussing in more detail (pay attention to the complementary explanation). The output from the ROM is available one clock cycle after the character address has been provided, and the least 3 significant bits of the column counter are used to select one of the 8 bits stored in each ROM location. This creates an artifact, where the first column for each font for each character is displayed __*after*__ the last column for the same character (thus substituting the first column for the following character, and so on). While for most characters this effect is not visible because both the first and the last columns do not carry any shape information, you should pay special attention to the 0 (zero) character. 

While, seemingly, the above problem can be addressed by delaying the 3 least significant bits of the column counter by one clock cycle before sampling one bit from the 8-bit output of the ROM, there is an additional artifact that must be accounted for: each bit from every character will be displayed one clock cycle later. To avoid this problem, __*all*__ the logic paths that originate in the video controller (i.e., column and line counters) must have the same latency, in terms of clock cycles, until the values on the R, G and B channels are loaded back in the video controller. Furthermore, the H\_SYNC and V\_SYNC signals must also be delayed in order to compensate for this additional latency. This is a common design practice that is employed whenever pipelining (insertion of intermediate registers) is used to break long combinational paths in data-flow intensive circuits. For video circuits in particular these long combinational paths create visual artifacts that can be clearly observed, as demonstrated by this experiment.

You have to perform the following tasks in the lab for this experiment:

* understand how the character ROM is interfaced to the rest of the design
* modify the RTL code to ensure that any path that originates from the column/row counters from the VGA controller has exactly the same latency in terms of clock cycles until it reaches the R, G and B registers in the VGA controller
* understand the resource usage in terms of registers - you should relate your estimate to the register count from the compilation report in Quartus

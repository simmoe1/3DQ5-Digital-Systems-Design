### Experiment 1

The objective of this experiment is to get you familiarized with SystemVerilog for design verification. 

Hardware description languages (HDLs), e.g., VHDL, Verilog, SystemVerilog, are employed for both describing hardware and verifying it. As shown in Figure 1, the aim of verification is to control the inputs of a design (using _drivers_) and to observe its internal states and outputs (using _monitors_) in order to ensure the correct behavior before the design is implemented. There are (System)Verilog language constructs which (as shown in the testbench for **experiment 1**) are used __exclusively__ for verification. Note, most of these language constructs do not have an equivalent hardware circuit, as they are used primarily to drive and monitor the design behavior through simulation. They are used in special verification modules called “testbenches”. A properly designed testbench will ensure that the design will work correctly as soon as it is implemented, e.g., programmed into a field-programmable gate array (FPGA) device.

| ![](design-verification.png) |
|:--:|
|**Figure 1** – Design verification using testbenches |
<a name="design-verification"></a>

Verifying the design through simulation can be done at different levels of design abstraction. The (System)Verilog source code can be simulated “fast” by using timing control and sensitivity lists (part of the language features for verification). This is called behavioral simulation and it is commonly at least one order of magnitude faster in terms of runtime than timing simulation. Timing simulation works on the implemented netlist and it uses accurate timing information, which is back-annotated from the technology library. Most of the iterative debugging is done by updating the register-transfer level (RTL) source code and running behavioral simulations. Only when the confidence is high about the design correctness, one should perform timing simulation and/or download the compiled bitstream to the FPGA.

Most of the essential language constructs for simulation will be learnt incrementally, as you progress through the labs and the project. It is worth mentioning that, unlike for the synthesizable RTL code, for driving purposes, in a testbench file one can update the same input in one or multiple `initial` and/or `always` blocks (nonetheless this should be done in a judicious manner to avoid race conditions). The timing of an update, can be controlled using, for example, `#`, which depending on its usage can delay the next evaluation and/or update by a user-specified time. For monitoring purposes, both in the `initial` and `always` blocks you can use the built-in _\$write_ or _\$display_ tasks that have similar behavior to _printf_ in C/C++ (note, a new line is implied for _\$display_). Custom tasks can also be defined and included in `initial` and `always` blocks. The timing can also be controlled either by checking if a condition is true and, if not, wait until it occurs (using `wait`) or by waiting for an event, e.g., a signal transition, to occur (using `@`).

The reference design from this experiment implements the same functionality as the reference design from __experiment 2__ from __lab 1__, i.e., it finds the index of the most significant switch that is _on_ (from switches 9 down to 0). You have to perform the following tasks in the lab for this experiment:

* expand the testbench (from the **tb** subfolder) to confirm the correctness of the design, by writing the code for the monitors for green LEDs and seven-segment displays, as well as by writing the code to emulate additional toggles on input switches 
* change the design (from the **rtl** subfolder) to find also the least significant switch that is _off_ (from switches 9 down to 0) and display its index on the leftmost (most significant) seven-segment display, and (in binary) on the green LEDs from position 7 down to 4; note, if all the switches are _on_ then assume that the least significant switch that is _off_ has index `4'hF`; verify that your design modifications are correct by updating the testbench (__note__: you should __not__ use waves for this experiment)
